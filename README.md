# Gapless Audio MSE
Gapless Audio MSE uses MSE to concatenate two encoded fragmented MP4 (AAC) files 
into a gapless audio stream. If player and MSE work correctly, the transition in
the middle of the timeline should be seamless and users shouldn't hear a pop.

To try it out, please visit [Gapless Audio MSE Demo](https://nzhang227.github.io/gapless_audio_mse/demo.html).

# Solution
Quote from [ISO-Init-Segments](https://www.w3.org/TR/mse-byte-stream-format-isobmff/#iso-init-segments):
> The user agent must support setting the offset from media composition time to movie presentation time by handling an Edit Box (edts) containing a single Edit List Box (elst) that contains a single edit with media rate one. This edit may have a duration of 0 (indicating that it spans all subsequent media) or may have a non-zero duration (indicating the total duration of the movie including fragments).

It's MSE's obligation to
* Parse ELST and get some gapless metadata like media_time, segment_duration and so on
* Shift timestamp according to media_time
* Trim extra leading/trailing samples as ELST suggests? The document is quite vague about it. But Chrome confirmed that currently Chrome MSE trims exactly leading samples as media_time suggests. So Let's assume other MSE implementations align with it.

So it seems like it's client's obligation to
* Trim extra trailing samples. The number can be got from final packet duration in TRUN.

Based on these assumptions, I've got GaplessAudioPlayer at [Gapless Audio MSE Demo](https://nzhang227.github.io/gapless_audio_mse/demo.html). But unforturnately, it doesn't work out as expected. Seems like most media stacks don't handle ELST correctly.

## Test Results
TODO

# Workaround
For now most MSE implementations don't handle ELST correctly and the behavior is quite unpredictable. To workaround those issues, player needs to remove all the special features that MSE implementations can mess up on when trimming. A reasonable workaround can be:
* Player parses ELST and get gapless metadata
* Player modifies the moov and moofs to remove ELST and reset final packet duration, before pushing moov (and moofs) into MSE
* According to gapless metadata, Player sets appendWindowStart/appendWindowEnd/timestampOffset in order to do timestamp shifting, front-trimming and end-trimming

Based on the workaround, I've got GaplessAudioPlayerWorkaround at [Gapless Audio MSE Demo](https://nzhang227.github.io/gapless_audio_mse/demo.html).

## Test Results


# Details about the test files
The gapless test files are under resources folder.

## About tone_(1|2).mp4
The flac files were generated by splitting a single file into 2 flacs.
Each flac is 110250 samples.

The flac files were re-encoded to AAC with an encoder which has an encoder delay
of 1600 samples, and muxed into fragmented mp4 files.
(These examples have single fragment, but others will not).

The FMP4 files were produced by
 * Setting mvhd.timescale and mdhd.timescale to the sample rate.
 * Adding single edit to edit list
 * Setting edit media time to 1600, to account for encoder delay.
 * Setting edit segment duration to 110250, to account for trailing samples due 
 to AAC packet sample count.
 * All presentation durations are also 110250, as they should be.
   (sidx durations, mvhd.duration, tkhd.duration, mdhd.duration)

The encoded AAC fragmented MP4 files have the following properties:
 * Encoder delay of 1600 samples.
 * Edit list with media time of 1600 and segment duration of 110250
 * In order to get gapless playback, 1600 leading samples and 790 trailing 
 samples should be trimmed
 * After trimming leading and trailing samples (due to edit list), there should 
 be 110250 samples.

Let's do some math:
* segment_duration = 110250 (2.5s)
* media_time =  1600
* total_frames = 110
* samples_per_frame = 1024
* total_samples_before_trim = total_frames * samples_per_frame = 112640
* total_samples_after_trim = segment_duration = 110250
* leading_samples_to_trim = 1600
* trailing_samples_to_trim = total_samples_before_trim - total_samples_after_trim - leading_samples_to_trim = 790

## About tone_(1|2)_no_elst.mp4
It seems like most media stacks don't handle ELST correctly. In order to workaround this, we have another test case to remove all the special features that browser can mess up on trimming. 

In order to do that, I manually changed the test files using a hex editor:
* Mark EDTS as SKIP box. Simply search in the binary for EDTS and change it to SKIP
* Set last packet duraion in TRUN back to 1024